// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

use anyhow::{Result, Error};
use libra_config::{
    config::{
        DiscoveryMethod, Identity, NodeConfig, OnDiskStorageConfig, SafetyRulesService,
        SecureBackend, SeedAddresses, WaypointConfig, HANDSHAKE_VERSION,
    },
    network_id::NetworkId
};
use libra_types::{
    waypoint::Waypoint,
    transaction::{TransactionOutput, TransactionStatus, WriteSetPayload, Transaction},
    validator_config::{ValidatorConfigResource, ValidatorOperatorConfigResource},
    write_set::{WriteOp, WriteSet},
    chain_id::ChainId,
};
use std::{fs::File, io::{Write, Read}, path::PathBuf, 
        str::FromStr
};
use libra_genesis_tool::{
    config_builder::{FullnodeBuilder, FullnodeType, ValidatorBuilder},
    swarm_config::SwarmConfig,
};
use move_core_types::move_resource::MoveResource;
use libra_genesis_tool::storage_helper::StorageHelper;

const LIBRA_ROOT_NS: &str = "libra_root";
const LIBRA_ROOT_SHARED_NS: &str = "libra_root_shared";
const OPERATOR_NS: &str = "_operator";
const OPERATOR_SHARED_NS: &str = "_operator_shared";
const OWNER_NS: &str = "_owner";
const OWNER_SHARED_NS: &str = "_owner_shared";

pub struct ValidatorBuilder<T: AsRef<Path>> {
    storage_helper: StorageHelper,
    num_validators: usize,
    randomize_first_validator_ports: bool,
    swarm_path: T,
    template: NodeConfig,
    genesis_blob_path: Option<PathBuf>
}
pub fn create_layout(&self) {
    let mut layout = Layout::default();
    //////// 0L ////////
    // layout.libra_root = LIBRA_ROOT_SHARED_NS.into();
    // layout.treasury_compliance = LIBRA_ROOT_SHARED_NS.into();
    layout.owners = (0..self.num_validators)
        .map(|i| (i.to_string() + OWNER_SHARED_NS))
        .collect();
    layout.operators = (0..self.num_validators)
        .map(|i| (i.to_string() + OPERATOR_SHARED_NS))
        .collect();

    let mut common_storage = self.storage_helper.storage(COMMON_NS.into());
    let layout_value = layout.to_toml().unwrap();
    common_storage.set(LAYOUT, layout_value).unwrap();
}

pub fn build(genesis_blob_path: &PathBuf, output_dir: &PathBuf) -> Result<SwarmConfig, Error> {
    dbg!(genesis_blob_path);
    let mut configs: Vec<NodeConfig> = vec![];
    let mut config_files = vec![];

    let mut file = File::open(genesis_blob_path)?;
    let mut buffer = vec![];
    file.read_to_end(&mut buffer)?;
    let genesis: Transaction = lcs::from_bytes(&buffer)?;
    let genesis_copy = genesis.clone();
    println!("111111111");
    match genesis_copy {
        Transaction::GenesisTransaction(write_set_payload) => {
            match write_set_payload {
                WriteSetPayload::Direct(change_set) => {
                    for write_set_item in change_set.write_set() {
                        if write_set_item.0.path==ValidatorConfigResource::resource_path() {
                            match &write_set_item.1 {
                                WriteOp::Deletion => {},
                                WriteOp::Value(value) => {
                                    let validator_config_resource: ValidatorConfigResource = lcs::from_bytes(&value)?;
                                    let name = String::from_utf8(validator_config_resource.human_name).unwrap();
                                    println!("222222222222");
                                    let mut config = generate_node_configs(name.clone(), &output_dir.clone(), genesis.clone(), &genesis_blob_path)?;
                                    println!("Validator: {}", name);
                                    let node_dir = output_dir.join(name.to_string());
                                    std::fs::create_dir_all(&node_dir)?;
        
                                    let node_path = node_dir.join("node.yaml");
                                    config.set_data_dir(node_dir);
                                    config.save(&node_path)?;
                                    config_files.push(node_path);
                                    configs.push(config);
                                    break;
                                }
                            };
                            
                        }
                    }
                },
                WriteSetPayload::Script{execute_as, script} => {
                    println!("Writeset script");
                }
            }
        }, Transaction::BlockMetadata(_data) => {
            println!("BlockMetadata");
        }, Transaction::UserTransaction(_data) => {
            println!("UserTransaction");
        }
    }

    let libra_root_key_path = output_dir.join("mint.key");
    let serialized_keys = lcs::to_bytes("")?;
    let mut key_file = File::create(&libra_root_key_path)?;
    key_file.write_all(&serialized_keys)?;

    Ok(SwarmConfig {
        config_files,
        libra_root_key_path,
        waypoint: configs[0].base.waypoint.waypoint(),
    })
}

pub fn generate_node_configs(human_name: String, output_dir: &PathBuf, genesis_txn: Transaction, genesis_blob_path: &PathBuf) -> Result<NodeConfig, Error> {
    let local_ns = human_name.clone() + OPERATOR_NS;
    let remote_ns = human_name.clone() + OPERATOR_SHARED_NS;
    
    let mut config = NodeConfig::default_for_validator();
    println!("333333333333");
    let storage_helper = StorageHelper::new();
    let waypoint = Waypoint::from_str("0:8ae1a4fe76662eb6e14a83d831ba7f7fee9b43eb9bb80bdf6e9f9a6c4b986906")?;

    storage_helper
    .insert_waypoint(&local_ns, waypoint.clone())
    .unwrap();

    let validator_network = config.validator_network.as_mut().unwrap();
    let fullnode_network = &mut config.full_node_networks[0];
    let validator_network_address = validator_network.listen_address.clone();
    let fullnode_network_address = fullnode_network.listen_address.clone();
    storage_helper
        .validator_config(
            &(human_name.clone() + OWNER_SHARED_NS),
            validator_network_address,
            fullnode_network_address,
            ChainId::test(),
            &local_ns,
            &remote_ns,
        )
        .unwrap();

    let backend = secure_backend(&storage_helper, &output_dir, &local_ns, "safety-rules");
    config.base.waypoint = WaypointConfig::FromConfig(waypoint);
    config.consensus.safety_rules.service = SafetyRulesService::Thread;

    config.consensus.safety_rules.backend = secure_backend(&storage_helper, &output_dir, &local_ns, "safety-rules");

    config.execution.backend = secure_backend(&storage_helper, &output_dir, &local_ns, "execution");
    config.execution.genesis = Some(genesis_txn);
    config.execution.genesis_file_location = genesis_blob_path.clone();
    println!("444444444444");


    let validator_identity = validator_network.identity_from_storage();
    validator_network.identity = Identity::from_storage(
        validator_identity.key_name,
        validator_identity.peer_id_name,
        secure_backend(&storage_helper, &output_dir, &local_ns, "validator")
    );
    validator_network.network_address_key_backend = Some(secure_backend(&storage_helper, &output_dir, &local_ns, "validator"));

    let fullnode_identity = fullnode_network.identity_from_storage();
    fullnode_network.identity = Identity::from_storage(
        fullnode_identity.key_name,
        fullnode_identity.peer_id_name,
        secure_backend(&storage_helper, &output_dir, &local_ns, "full_node")
    );

    Ok(config)
}

pub fn secure_backend(storage_helper: &StorageHelper, output_dir: &PathBuf, human_name: &str, usage: &str) -> SecureBackend {
    let original = storage_helper.path();
    let dst_base = std::path::Path::new(output_dir.to_str().unwrap());
    let mut dst = dst_base.to_path_buf();
    dst.push(format!("{}_{}", human_name, usage));
    std::fs::copy(original, &dst).unwrap();

    let mut storage_config = OnDiskStorageConfig::default();
    storage_config.path = dst;
    storage_config.set_data_dir(PathBuf::from(""));
    storage_config.namespace = Some(human_name.into());
    SecureBackend::InMemoryStorage
}

#[test]
pub fn test() -> Result<()> {
    use std::path::Path;

    let path = env!("CARGO_MANIFEST_DIR");
    let genesis_path = Path::new(path)
        .parent()
        .unwrap()
        .join("../../.0L/genesis_from_snapshot.blob");

    let config_path = Path::new(path)
    .parent()
    .unwrap()
    .join("../../.0L/swarm_temp");
    let config = build(&genesis_path, &config_path).unwrap();
    Ok(())
}